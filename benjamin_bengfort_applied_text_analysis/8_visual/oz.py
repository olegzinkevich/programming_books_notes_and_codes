#  работает, можно использовать - какие бренды, с какими упоминались. см. oz.json и cast dict.

# работает

import json
import codecs
import itertools
import networkx as nx

import numpy as np
import matplotlib.pyplot as plt
import matplotlib

from matplotlib.colors import LogNorm
from nltk import sent_tokenize, word_tokenize

# Since we will be representing the Oz characters as nodes in the graph, we need to # establish the linkages between nodes. We can write a cooccurrence function that # scans through each chapter, and for every possible pair of characters, checks how # often both appear together.

# We initialize a dictionary with keys for each possible pair,
# then for each chapter, we use NLTK’s sent_tokenize method to parse the text into
# sentences, and for each sentence that contains both characters’ names, we increment
# the dictionary value by one:
def cooccurrence(text, cast):
    possible_pairs = list(itertools.combinations(cast, 2))
    cooccurring = dict.fromkeys(possible_pairs, 0)
    for title, chapter in text['chapters'].items():
        for sent in sent_tokenize(chapter):
            for pair in possible_pairs:
                if pair[0] in sent and pair[1] in sent:
                    cooccurring[pair] += 1
    return cooccurring


# Co-occurrence is another way to quickly understand relationships between entities or
# other n-grams, in terms of the frequency with which they appear together. First, we create a function matrix that will take in the text of the book and the list of characters. We initialize a multidimensional array that will be a list that contains a list for every character with the count of its co-occurrences with every other character:
def matrix(text, cast):
    mtx = []
    for first in cast:
        row = []
        for second in cast:
            count = 0
            for title, chapter in text['chapters'].items():
                for sent in sent_tokenize(chapter):
                    if first in sent and second in sent:
                        count += 1
            row.append(count)
        mtx.append(row)
    return mtx


if __name__ == '__main__':

    # Next, we’ll open our JSON file, load the text, extract the list of characters, and initialize a NetworkX graph. For each pair generated by our cooccurrence function with a nonzero value, we’ll add an edge that stores the co-occurrence count as a property.

    # File contains a list of characters, reverse sorted by frequency
    # And a dict with {chapter title: chapter text} key-value pairs
    with codecs.open('data/oz.json', 'r', 'utf-8-sig') as data:
        text = json.load(data)
        cast = text['cast']

        # We’ll then perform an ego_graph extraction on the graph that sets Dorothy as the
# center. We use a spring_layout to push nodes away from her in inverse proportion
# to their shared edge weight, specifying the desired distance between nodes using the k
# parameter (to avoid a hairball), and the number of iterations of spring-force relaxation
# with the iterations parameter. Finally, we use NetworkX’s draw method to generate
# a Matplotlib figure with the desired node and edge colors and sizes, specifying
# that the node labels (the character names) be shown in a font that will be big enough
# to read
        ##############################################
        # Build a NetworkX Graph
        ##############################################
        G = nx.Graph()
        G.name = "The Social Network of Oz"
        pairs = cooccurrence(text, cast)

        for pair, wgt in pairs.items():
            if wgt>0:
                G.add_edge(pair[0], pair[1], weight=wgt)
        # Make Dorothy the center
        D = nx.ego_graph(G, "Dorothy")
        edges, weights = zip(*nx.get_edge_attributes(D, "weight").items())
        # Push nodes away that are less related to Dorothy
        pos = nx.spring_layout(D, k=.5, iterations=40)
        nx.draw(D, pos, node_color="gold", node_size=50, edgelist=edges,
                width=.5, edge_color="orange", with_labels=True, font_size=12)

        # The resulting plot shown in Figure 8-2 very effectively illustrates Dorothy’s relationships # in the book; the nodes closest to her include her closest allies—her dog, Toto,
# the Scarecrow, and the Tin Woodman, while those on the outer edges are characters
# with whom Dorothy interacts the least. The social graph also shows Dorothy’s close
# promixity to Oz and the Wicked Witch, both of whom she has significant, albeit
# more complex, relationships

        plt.show()

        # We can now plot our matrix. To approximate the D3 plots, we want to plot two cooccurrence # matrices side by side; one with the characters ordered alphabetically and
# one where they are ordered by overall frequency in the text. We’ll initialize a figure
# and axes, add a title and increase the default whitespace between the subplots to
# ensure there will be room for the characters names, and create enough x- and y-tick
# marks to correspond to every character.

        ##############################################
        # Plot a Co-Occurrence Matrix
        ##############################################

        # First make the matrices
        # By frequency
        mtx = matrix(text,cast)
        # And alphabetically
        alpha_cast = sorted(cast)
        alpha_mtx = matrix(text,alpha_cast)

        # Now create the plots
        fig, ax = plt.subplots()
        fig.suptitle('Character Co-occurrence in the Wizard of Oz', fontsize=12)
        fig.subplots_adjust(wspace=.75)

        n = len(cast)
        x_tick_marks = np.arange(n)
        y_tick_marks = np.arange(n)

        ax1 = plt.subplot(121)
        ax1.set_xticks(x_tick_marks)
        ax1.set_yticks(y_tick_marks)
        ax1.set_xticklabels(cast, fontsize=8, rotation=90)
        ax1.set_yticklabels(cast, fontsize=8)
        ax1.xaxis.tick_top()
        ax1.set_xlabel("By Frequency")
        plt.imshow(mtx, norm=matplotlib.colors.LogNorm(), interpolation='nearest', cmap='YlOrBr')

        ax2 = plt.subplot(122)
        ax2.set_xticks(x_tick_marks)
        ax2.set_yticks(y_tick_marks)
        ax2.set_xticklabels(alpha_cast, fontsize=8, rotation=90)
        ax2.set_yticklabels(alpha_cast, fontsize=8)
        ax2.xaxis.tick_top()
        ax2.set_xlabel("Alphabetically")
        plt.imshow(alpha_mtx, norm=matplotlib.colors.LogNorm(), interpolation='nearest', cmap='YlOrBr')
        plt.show()

#         # dispersion plots
# While the network and co-occurrence plots do begin to elucidate the relationships
# between entities in a text (or characters in a plot), as well as which entities play some
# of the most important roles, they do not reflect very much about their various roles in

# A dispersion plot provides a kind of “x-ray” of the text, plotting each character name
# along the y-axis and having the narrative plotted along the x-axis, such that a horizontal
# line can be added next to each character at the points in which he or she
# appears in the plot

        ##############################################
        # Plot mentions of characters through chapters
        ##############################################
        oz_words = []
        headings = []
        chap_lens = []
        for heading, chapter in text['chapters'].items():
            # Collect the chapter headings
            headings.append(heading)
            for sent in sent_tokenize(chapter):
                for word in word_tokenize(sent):
                    # Collect all of the words
                    oz_words.append(word)
            # Record the word lengths at each chapter
            chap_lens.append(len(oz_words))

        # Mark where chapters start
        chap_starts = [0] + chap_lens[:-1]
        # Combine with chapter headings
        chap_marks = list(zip(chap_starts,headings))

#         # Now we want to search through the list of oz_words to look for places where the
# characters appear, adding these to a list of points for plotting. In our case, some of
# our characters have one-word names (e.g., “Dorothy,” “Scarecrow,” “Glinda”), while
# others have two-word names (“Cowardly Lion,” “Monkey King”). To ensure we match
# types of strings, we’ll first catalog the one-word name matches, checking for each
# word in the text to see if it matches a name, and then we’ll look for the two-name
# characters by looking at each word together with its preceding word:
        cast.reverse()
        points = []
        # Add a point for each time a character appears
        for y in range(len(cast)):
            for x in range(len(oz_words)):
                # Some characters have 1-word names
                if len(cast[y].split()) == 1:
                    if cast[y] == oz_words[x]:
                        points.append((x,y))
                # Some characters have 2-word names
                else:
                    if cast[y] == ' '.join((oz_words[x-1], oz_words[x])):
                        points.append((x,y))
        if points:
            x, y = list(zip(*points))
        else:
            x = y = ()

        # Create the plot
        fig, ax = plt.subplots(figsize=(12,6))
        # Add vertical lines labeled for each chapter start
        for chap in chap_marks:
            plt.axvline(x=chap[0], linestyle='-',
                color='gainsboro')
            plt.text(chap[0], -2, chap[1], size=6, rotation=90)
        # Plot the character mentions
        plt.plot(x, y, "|", color="darkorange", scalex=.1)
        plt.tick_params(
            axis='x', which='both', bottom='off', labelbottom='off'
        )
        plt.yticks(list(range(len(cast))), cast, size=8)
        plt.ylim(-1, len(cast))
        plt.title("Character Mentions in the Wizard of Oz")
        plt.show()
